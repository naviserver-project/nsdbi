
*) Make sure results are utf8 encoded. Contract is: drivers always return data
   as utf-8 strings, no matter what the db uses internaly.

   Other rules:
     date format (ISO?)
     timezone (UTC?)
     autocommit on/off?


*) How to send/recieve binary data between database? Could check bound
   variables type: if bytearray, use Tcl_GetByteArray* instead of
   Tcl_GetString*. But what about data coming back? Maybe an extra switch:

     # The 2nd and 3rd columns are binary.
     dbi_rows -binary {1 2} {select a, b, c from x}

   Will need driver support.


*) A standard scheme for common database errors such as 'duplicate row' when
   inserting a new row with a primary key which is already taken. Turn these
   into exceptions so that Tcl code can catch them.


*) How to pass NULLs to the database?

     set x [dbi null]
     dbi_dml {update ... :x}


*) Handle caching is mostly transparent, but requires some ugliness to auto
   release handles before conn IO. A cleaner, although less transparent way to
   handle this might be:

     dbi_withhandle -pool x {
         dbi 1row {query...}
         dbi 1row {query...}
     }


*) Do we also need to handle transactions in Tcl code?

     dbi_transaction -pool x {
         dbi ...
         dbi ...
     }

If it's not absolutely necessary it would be nice to skip this. Is it better
to compose reuseable chunks of SQL in Tcl, or to use the db, views etc.?


*) Result assertions don't roll back transactions. e.g.:

     dbi_rows {update ...}

   We were expecting rows, but got a DML result because of a bad query. A Tcl
   error will be thrown, but the DML is not rolled back. This would require
   opening an closing a transaction for every query. Is this slow?


*) Result caching: Caching the results from a db query is easy, but flushing
   is complicated. You often want to flush a whole class of cached results
   because they depend upon the values in some other table which was just
   updated. Perhaps results can be cached with multiple keys:

     # All 'it' results flushed atomically.
     dbi_dml -cachekey it$id -cachekey it {update ... :id ...}

     # Return cached result for key it$id if available.
     dbi_rows -cachekey it$id {select ... :id ...}

     # Flush every 'it'.
     dbi_flush -cachekey it


*) Limits for pools?  Set max handles, default pool etc. per urlspecific
   data. So: dbi commands run from pages under /foo/bar would by default get a
   handle from pool x if none specified.  If there are 6 concurrent pages
   running under /foo/bar and there are 10 handles in pool x but the limit
   says 6, the next page will have to wait.

   The goal is to abstract pool names from Tcl code.  Pool names can change --
   they should be in a config file.  e.g. a site grows large and partitions
   user data into two databases: user names a-m -> pool1, user names n-z pool2
   etc.


*) Add Url2Pool callbacks (See url2file) to determine which handle to use
   when?  e.g. round-robin requests between 3 databases?


*) Add higher level Tcl commands 'update', 'insert' etc.

     set a(x) 1; set a(y) 2; set a(z) 3

     dbi_update tablex $a

     # Translates to:

     dbi_dml -bindarray a -- {
         update tablex set x = :x, y = :y, z = :z
     }

     # And:

     dbi_insert tablex $a

     # Translates to:

     dbi_dml -bindarray a -- {
         insert into tablex
         (x, y, z)
         values
         (:x, :y, :z)
     }

     # MySQL has this native. Others could wrap in a transaction:
     # If row exists, update. Otherwise, insert (atomically).

     dbi_insertorupdate tablex $a


*) Predefined schema queries for drivers. i.e. you want to know which tables
   are defined, or how many columns a table has.  Drivers supply a string of
   SQL which returns the correct answer. Can overide in config file for weird
   db setups.

     foreach table [dbi_tables pool1] {
         dbi_columns $table
     }


*) Dynamically change pool config.

     dbi_pool maxconnections
     5                           ;# current handles
     dbi_pool maxconnections 10
     5                           ;# old handles
     dbi_pool maxconnection
     10                          ;# current handles


*) Transparent support for various keyed data structures: sets, arrays,
   TclX keyed lists, Tcl8.5 dicts:

     # Figure out what $x is and do the right thing.
     dbi_rows -bind $x {query ...}


*) Array opperations (Oracle array DML etc.) with native driver support?

     # 3 inserts in single transation, efficiently:
     dbi_dml {insert into tablex (x) values (:x)} a b c


*) Does it make sense to extend the C API with new features when there are
   already so many databse C APIs out there? Perhaps we should just use one of
   them?


*) Asynchronous API. Send a query to the db, initiate an HTTP request to some
   outside service, submit an ns_job: *concurrently*.  Wait for all the
   results to come back.

   This could be extended so that multiple db queries are submitted from
   within the driver thread.  A conn thread would only be allocated when
   notification that all query results are ready. This would prevent conn
   threads sitting idle waiting for db I/O.

   The hard part is coming up with an API which is actually workable.

