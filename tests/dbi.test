#
# Test Suite
#


package require tcltest 2.2
namespace import -force ::tcltest::*

eval ::tcltest::configure $argv




test pools {list all pools} -body {
    lsort [dbi_ctl pools]
} -result {OPENERR OPENERR0 global1 global2 pool1 pool2}


test default {default pool} -body {
    dbi_ctl default
} -result pool1



test ctl.1 {driver} -body {
    dbi_ctl driver pool1
} -result test

test ctl.2 {database} -body {
    dbi_ctl database pool1
} -result db

test ctl.3 {default} -body {
    dbi_ctl default
} -result pool1

test ctl.4 {maxhandles} -body {
    dbi_ctl maxhandles pool1
} -result [ns_config ns/server/server1/module/pool1 maxhandles -1]

test ctl.5 {maxidle} -body {
    dbi_ctl maxidle pool1
} -result [ns_config ns/server/server1/module/pool1 maxidle -1]

test ctl.6 {maxopen} -body {
    dbi_ctl maxopen pool1
} -result [ns_config ns/server/server1/module/pool1 maxopen -1]

test ctl.7 {maxqueries} -body {
    dbi_ctl maxqueries pool1
} -result [ns_config ns/server/server1/module/pool1 maxqueries -1]

test ctl.8 {change config} -body {
    set old [dbi_ctl maxhandles pool1 99]
    set new [dbi_ctl maxhandles pool1 $old]
    list $old $new
} -result "[ns_config ns/server/server1/module/pool1 maxhandles -1] 99"



test stats.1 {pool stats} -body {
     array set a [dbi_ctl stats pool1]
     lsort [array names a]
} -cleanup {
    unset -nocomplain a
} -result {agedcloses bounces handlefailures handlegets handlemisses handleopens idlecloses oppscloses queries}



test open-1.1 {simulate driver open callback failure} -body {
    dbi_rows -pool OPENERR {ROWS 1 1}
} -returnCodes error -result {handle allocation failed}



test prepare-1 {simulate driver prepare callback failure} -body {
    dbi_rows {PREPERR 1 1}
} -returnCodes error -result {test: prepare failure}



test dml-1 {dml} -body {
    dbi_dml {DML 0 0}
} -result ""

test dml-2 {dml error} -body {
    dbi_dml {ROWS 1 1}
} -returnCodes error -result {query was not a DML or DDL command.}



test 0or1row-1 {found single column} -body {
    dbi_0or1row {ROWS 1 1 v}
    set 0
} -cleanup {
    unset -nocomplain 0
} -result v

test 0or1row-2 {found multiple columns} -body {
    dbi_0or1row {ROWS 3 1 v}
    list $0 $1 $2
} -cleanup {
    unset -nocomplain 0 1 2
} -result {v v v}

test 0or1row-3 {not found} -body {
    set 0 x
    dbi_0or1row {ROWS 1 0}
    set 0
} -cleanup {
    unset -nocomplain 0
} -result x

test 0or1row-5 {query error} -body {
    dbi_0or1row {EXECERR 1 1}
} -returnCodes error -result {driver error}



test 1row-1 {found single column} -body {
    dbi_1row {ROWS 1 1 v}
    set 0
} -cleanup {
    unset -nocomplain 0
} -result v

test 1row-2 {found multiple columns} -body {
    dbi_1row {ROWS 3 1 v}
    list $0 $1 $2
} -cleanup {
    unset -nocomplain 0 1 2
} -result {v v v}

test 1row-3 {clobber existing variable} -body {
    set 0 x
    dbi_1row {ROWS 1 1 v}
    set 0
} -cleanup {
    unset -nocomplain 0
} -result v

test 1row-4 {1row not found} -body {
    dbi_1row {ROWS 1 0}
} -returnCodes error -result {query was not a statement returning rows}

test 1row-5 {query error} -body {
    dbi_1row {EXECERR 1 1}
} -returnCodes error -result {driver error}



test rows-1 {found 1 row, 1 column} -body {
    dbi_rows {ROWS 1 1 v}
} -result v

test rows-2 {found 1 rows, 2 columns} -body {
    dbi_rows {ROWS 2 1 v}
} -result {v v}

test rows-3 {found 1 row, 3 columns} -body {
    dbi_rows {ROWS 3 1 v}
} -result {v v v}

test rows-4 {found 2 rows, 1 column} -body {
    dbi_rows {ROWS 1 2 v}
} -result {v v}

test rows-5 {found 2 rows, 2 columns} -body {
    dbi_rows {ROWS 2 2 v}
} -result {v v v v}

test rows-6 {found 2 rows, 3 columns} -body {
    dbi_rows {ROWS 3 2 v}
} -result {v v v v v v}

test rows-7 {query error} -body {
    dbi_rows {EXECERR 1 1}
} -returnCodes error -result {driver error}



test pool-global {query from non-default global pool} -body {
    dbi_rows -pool global1 {ROWS 1 1 v}
} -result v




test thread-handle-1.1 {maxhandles 0} -body {
    dbi_rows -pool global2 {ROWS 1 1 v}
} -result v

test thread-handle-1.2 {maxhandles 0, thread exit w/handle cleanup} -body {
    ns_thread wait [ns_thread begin {
        dbi_rows -pool global2 {ROWS 1 1 v}
    }]
} -result v

test thread-handle-1.3 {maxhandles 0, thread handle reuse} -body {
    ns_thread wait [ns_thread begin {
        dbi_rows -pool global2 {ROWS 1 1 v}
        dbi_rows -pool global2 {ROWS 1 1 v}
    }]
} -result v

test thread-handle-1.4 {maxhandles 0/1/0} -body {

    dbi_ctl maxhandles global2 0

    ns_thread wait [ns_thread begin {
        dbi_rows -pool global2 {ROWS 1 1 v}
        dbi_ctl maxhandles global2 1
    }]

    ns_thread wait [ns_thread begin {
        dbi_rows -pool global2 -timeout 3 {ROWS 2 2 v}
    }]

} -cleanup {
    dbi_ctl maxhandles global2 0
} -match glob -result {wait for database handle timed out*}

test thread-handle-1.5 {maxhandles 0/2/0} -body {

    dbi_ctl maxhandles global2 0

    ns_thread wait [ns_thread begin {
        dbi_rows -pool global2 {ROWS 1 1 v}
        dbi_ctl maxhandles global2 2
    }]

    ns_thread wait [ns_thread begin {
        dbi_rows -pool global2 -timeout 2 {ROWS 1 2 v}
    }]

} -cleanup {
    dbi_ctl maxhandles global2 0
} -result {v v}

test thread-handle-1.6 {maxhandles 0/2/0/0} -body {

    dbi_ctl maxhandles global2 0

    ns_thread wait [ns_thread begin {
        dbi_rows -pool global2 {ROWS 1 1 v}
        dbi_ctl maxhandles global2 2
    }]

    ns_thread wait [ns_thread begin {
        dbi_rows -pool global2 -timeout 1 {ROWS 1 2 v}
        dbi_rows -pool global2 -timeout 1 {ROWS 1 3 v}
        dbi_ctl maxhandles global2 0
        dbi_rows -pool global2 -timeout 1 {ROWS 1 4 v}
    }]

} -cleanup {
    dbi_ctl maxhandles global2 0
} -result {v v v v}

test thread-handle-1.7 {open error} -body {
    dbi_rows -pool OPENERR0 {ROWS 1 1}
} -returnCodes error -result {handle allocation failed}




test poolhandle-1 {cache pool pointer in pool name obj} -body {
    set poolname pool1
    dbi_rows -pool $poolname {ROWS 1 1}
    dbi_rows -pool $poolname {ROWS 1 1}
    set poolname
} -result pool1



test bindvars-1 {local variable} -body {
    set x X
    dbi_rows {ROWS 2 1 :x}
} -cleanup {
    unset -nocomplain x
} -result {{X 0:x} v}

test bindvars-1.1 {missing local variable} -body {
    dbi_rows {ROWS 1 1 :x}
} -returnCodes error -result {can't read "x": no such variable}

test bindvars-2 {duplicate bind vars} -body {
    set x X
    set y Y
    dbi_rows {ROWS 2 1 :x :y :x}
} -cleanup {
    unset -nocomplain x y
} -result {{X Y X {0:x 1:y 2:x}} v}

test bindvars-3 {quoted bind var} -body {
    dbi_rows {ROWS 2 1 query ':x' query}
} -result {{{query ':x' query}} v}

test bindvars-4 {quoted bind var string 0, end-1} -body {
    dbi_rows {ROWS 2 1 ':x'}
} -result {':x' v}

test bindvars-5 {quoted bind var with spaces} -body {
    dbi_rows {ROWS 2 1 query ' :x ' query}
} -result {{{query ' :x ' query}} v}

test bindvars-6 {double quoted bind var} -body {
    set x X
    dbi_rows {ROWS 2 1 query '':x'' query}
} -cleanup {
    unset -nocomplain x
} -result {{X {query ''0:x'' query}} v}

test bindvars-7 {exceed max bind vars} -body {
    dbi_rows {ROWS 1 1 :1 :2 :3 :4 :5 :6 :7 :8 :9 :10 :11 :12 :13 :14 :15 :16 :17 :18 :19 :20 :21 :22 :23 :24 :25 :26 :27 :28 :29 :30 :31 :32 :33}
} -returnCodes error -result {max bind variables exceeded: 32}

test bindvars-8 {bound vars get reset} -body {
    set x 1
    set r [dbi_rows {ROWS 2 1 :x}]
    set x 2
    lappend r [dbi_rows {ROWS 2 1 :x}]
} -cleanup {
    unset -nocomplain x
} -result {{1 0:x} v {{2 0:x} v}}

test bindvars-9 {null bind var} -body {
	set x ""
	dbi_rows {ROWS 1 1 :x}
} -cleanup {
	unset -nocomplain x
} -result {{{} 0:x}}

test bindvars-10 {multiple null bind vars} -body {
	set x ""
	set y Y
	set z ""
	dbi_rows {ROWS 1 1 :x :y :z}
} -cleanup {
	unset -nocomplain x y z
} -result {{{} Y {} {0:x 1:y 2:z}}}




test binary-1 {binary variables and result values} -body {
	set x [binary format a1 ""]
	set y [binary format a8 ""]
	lindex [dbi_rows {BINARY 1 2 :x :y}] 1
} -cleanup {
	unset -nocomplain x y
} -result [binary format a8 ""]




test bindarray-1 {bind array vars} -body {
    set a(x) X
    set a(y) Y
    dbi_rows -bind a -- {ROWS 2 1 :x :y}
} -cleanup {
    unset -nocomplain a
} -result {{X Y {0:x 1:y}} v}

test bindarray-2 {bind missing value} -body {
    dbi_rows -bind a -- {ROWS 2 1 :x}
} -returnCodes error -result {can't read "a(x)": no such variable}

test bindarray-3 {bind non-array} -body {
    set a b
    dbi_rows -bind a -- {ROWS 2 1 :x}
} -returnCodes error -result {can't read "a(x)": variable isn't array}



test bindset-1 {bind ns_set} -body {
    set s [ns_set create]
    ns_set put $s x X
    ns_set put $s y Y
    dbi_rows -bind $s -- {ROWS 2 1 :x :y}
} -cleanup {
    ns_set free $s
} -result {{X Y {0:x 1:y}} v}




test bounce-1 {bounce pool} -body {
    dbi_ctl bounce pool1
} -result {}



test withhandle-1 {two queries, same handle} -body {
    dbi_eval {
        dbi_rows {ROWS 2 2 foo}
        dbi_rows {ROWS 2 2 bar}
    }
} -result {bar v v v}

test withhandle-2 {two queries, same handle, global pool} -body {
    dbi_eval -pool global1 {
        dbi_rows {ROWS 2 2 foo}
        dbi_rows {ROWS 2 2 bar}
    }
} -result {bar v v v}

test withhandle-3 {two queries, different handles} -body {
    dbi_eval -pool global1 {
        dbi_rows {ROWS 2 2 foo}
        dbi_rows -pool pool1 {ROWS 2 2 bar}
    }
} -result {bar v v v}

test withhandle-4 {two queries, different handles} -body {
    dbi_eval {
        dbi_rows {ROWS 2 2 foo}
        dbi_rows -pool global1 {ROWS 2 2 bar}
    }
} -result {bar v v v}

test withhandle-4 {nested call} -body {
    dbi_eval {
        dbi_eval {
            dbi_rows {ROWS 2 2 v}
        }
    }
} -result {v v v v}



test transaction-1 {basic transaction} -body {
    dbi_eval -transaction repeatable {
        dbi_dml {DML 0 0 foo}
        dbi_dml {DML 0 0 bar}
    }
} -result ""

test transaction-2 {transaction error, rollback} -body {
    dbi_eval -transaction repeatable {
        dbi_rows {ROWS 2 2 foo}
        error "some transaction error"
    }
} -returnCodes error -result {some transaction error}



test timeout-1 {timeout getting handle, relative time} -body {
    ns_thread begindetached {
        dbi_rows -pool pool2 -- {SLEEP 3 0}
    }
    after 1000
    dbi_rows -timeout 1 -pool pool2 -- {ROWS 2 2}
} -returnCodes error -result {wait for database handle timed out}

test timeout-2 {timeout getting handle, absolute time} -body {
    ns_thread begindetached {
        dbi_rows -pool pool2 -- {SLEEP 3 0}
    }
    after 1000
    dbi_rows -timeout [ns_time incr [ns_time get] 1] -pool pool2 -- {ROWS 2 2}
} -returnCodes error -result {wait for database handle timed out}




cleanupTests
