#
# Test Suite
#


package require tcltest 2.2
namespace import -force ::tcltest::*

eval ::tcltest::configure $argv



test basic-syntax.1 {check the basic syntax and arg handling} -body {
    dbi
} -returnCodes error -result {wrong # args: should be "dbi command ?args?"}

test basic-syntax.2 {check the basic syntax and arg handling} -body {
    dbi ?
} -returnCodes error -result {bad command "?": must be 0or1row, 1row, bounce, default, dml, info, pools, rows, stats, or withhandle}



test pools {list all pools} -body {
    lsort [dbi pools]
} -result {global1 global2 pool1 pool2}


test default {default pool} -body {
    dbi default
} -result pool1



test info.1 {pool info} -body {
    dbi info [dbi default]
} -cleanup {
    unset -nocomplain a
} -result {driver test database db}



test stats.1 {pool stats} -body {
     array set a [dbi stats pool1]
     lsort [array names a]
} -cleanup {
    unset -nocomplain a
} -result {agedcloses bounces handlefailures handlegets handlemisses handleopens idlecloses oppscloses queries}



test prepare-1 {prepare callback failure} -body {
    dbi rows {NOPREPARE}
} -returnCodes error -result {test: prepare failure}



test dml-1 {dml} -body {
    dbi dml {DML 0 3}
} -result 3

test dml-2 {dml error} -body {
    dbi dml {ROWS 1 1}
} -returnCodes error -result {query was not a DML or DDL command}



test 0or1row-1 {found single column} -body {
    dbi 0or1row {ROWS 1 1 v}
} -result v

test 0or1row-2 {found multiple columns} -body {
    dbi 0or1row {ROWS 3 1 v}
} -result {v v v}

test 0or1row-3 {not found} -body {
    dbi 0or1row {ROWS 1 0}
} -result {}

test 0or1row-4 {no columns} -body {
    dbi 0or1row {ROWS 0 1}
} -returnCodes error -result {bug: driver returned rows but failed to set number of columns}

test 0or1row-5 {query error} -body {
    dbi 0or1row {ERROR}
} -returnCodes error -result {driver error}



test 1row-1 {found single column} -body {
    dbi 1row {ROWS 1 1 v}
} -result v

test 1row-2 {found multiple columns} -body {
    dbi 1row {ROWS 3 1 v}
} -result {v v v}

test 1row-3 {1row not found} -body {
    dbi 1row {ROWS 1 0}
} -returnCodes error -result {query was not a statement returning rows}

test 1row-4 {query error} -body {
    dbi 1row {ERROR}
} -returnCodes error -result {driver error}



test rows-1 {found 1 row, 1 column} -body {
    dbi rows {ROWS 1 1 v}
} -result v

test rows-2 {found 1 row, 3 columns} -body {
    dbi rows {ROWS 3 1 v}
} -result {v v v}

test rows-3 {found 2 rows, 1 column} -body {
    dbi rows {ROWS 1 2 v}
} -result {v v}

test rows-4 {no rows} -body {
    dbi rows {ROWS 0 0}
} -returnCodes error -result {bug: driver returned rows but failed to set number of columns}

test rows-5 {query error} -body {
    dbi rows {ERROR}
} -returnCodes error -result {driver error}



test pool-global {query from non-default global pool} -body {
    dbi rows -pool global1 {ROWS 1 1 v}
} -result v


test poolhandle-1 {cache pool pointer in pool name obj} -body {
    set poolname pool1
    dbi rows -pool $poolname {ROWS 1 1}
    dbi rows -pool $poolname {ROWS 1 1}
    set poolname
} -result pool1



test bindvars-1 {local variable} -body {
    set x X
    dbi rows {ROWS 2 1 :x}
} -cleanup {
    unset -nocomplain x
} -result {{X 0:x} v}

test bindvars-1.1 {missing local variable} -body {
    dbi rows {ROWS 1 1 :x}
} -returnCodes error -result {can't read "x": no such variable}

test bindvars-2 {duplicate bind vars} -body {
    set x X
    set y Y
    dbi rows {ROWS 2 1 :x :y :x}
} -cleanup {
    unset -nocomplain x y
} -result {{X Y X {0:x 1:y 2:x}} v}

test bindvars-3 {quoted bind var} -body {
    dbi rows {ROWS 2 1 query ':x' query}
} -result {{{query ':x' query}} v}

test bindvars-4 {quoted bind var string 0, end-1} -body {
    dbi rows {ROWS 2 1 ':x'}
} -result {':x' v}

test bindvars-5 {quoted bind var with spaces} -body {
    dbi rows {ROWS 2 1 query ' :x ' query}
} -result {{{query ' :x ' query}} v}

test bindvars-6 {double quoted bind var} -body {
    set x X
    dbi rows {ROWS 2 1 query '':x'' query}
} -cleanup {
    unset -nocomplain x
} -result {{X {query ''0:x'' query}} v}

test bindvars-7 {exceed max bind vars} -body {
    dbi rows {ROWS 1 1 :1 :2 :3 :4 :5 :6 :7 :8 :9 :10 :11 :12 :13 :14 :15 :16 :17 :18 :19 :20 :21 :22 :23 :24 :25 :26 :27 :28 :29 :30 :31 :32 :33}
} -returnCodes error -result {max bind variables exceeded: 32}

test bindvars-8 {bound vars get reset} -body {
    set x 1
    set r [dbi rows {ROWS 2 1 :x}]
    set x 2
    lappend r [dbi rows {ROWS 2 1 :x}]
} -cleanup {
    unset -nocomplain x
} -result {{1 0:x} v {{2 0:x} v}}



test bindarray-1 {bind array vars} -body {
    set a(x) X
    set a(y) Y
    dbi rows -bindarray a -- {ROWS 2 1 :x :y}
} -cleanup {
    unset -nocomplain a
} -result {{X Y {0:x 1:y}} v}

test bindarray-2 {bind missing array} -body {
    dbi rows -bindarray a -- {ROWS 2 1 :x}
} -returnCodes error -result {can't read "a(x)": no such variable}

test bindarray-3 {bind non-array} -body {
    set a b
    dbi rows -bindarray a -- {ROWS 2 1 :x}
} -returnCodes error -result {can't read "a(x)": variable isn't array}



test bindset-1 {bind ns_set} -body {
    set s [ns_set create]
    ns_set put $s x X
    ns_set put $s y Y
    dbi rows -bindset $s -- {ROWS 2 1 :x :y}
} -cleanup {
    ns_set free $s
} -result {{X Y {0:x 1:y}} v}

test bindset-2 {bind missing set} -body {
    dbi rows -bindset s -- {ROWS 2 1 :x}
} -returnCodes error -result {no such set: s}




test bounce-1 {bounce pool} -body {
    dbi bounce pool1
} -result {}



test withhandle-1 {two queries, same handle} -body {
    dbi withhandle {
        dbi rows {ROWS 2 2 foo}
        dbi rows {ROWS 2 2 bar}
    }
} -result {bar v v v}

test withhandle-2 {two queries, same handle, global pool} -body {
    dbi withhandle -pool global1 {
        dbi rows {ROWS 2 2 foo}
        dbi rows {ROWS 2 2 bar}
    }
} -result {bar v v v}



test timeout-1 {timeout getting handle, relative time} -body {
    ns_thread begindetached {
        dbi rows -pool pool2 -- {SLEEP 3 0}
    }
    after 1000
    dbi rows -timeout 1 -pool pool2 -- {ROWS 2 2}
} -returnCodes error -result {wait for database handle timed out}

test timeout-2 {timeout getting handle, absolute time} -body {
    ns_thread begindetached {
        dbi rows -pool pool2 -- {SLEEP 3 0}
    }
    after 1000
    dbi rows -timeout [ns_time incr [ns_time get] 1] -pool pool2 -- {ROWS 2 2}
} -returnCodes error -result {wait for database handle timed out}



cleanupTests
